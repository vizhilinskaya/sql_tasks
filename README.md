# SQL-Karpov-Solved-Exercises

Решенные мною задачи из курса ["Симулятор SQL"](https://lab.karpov.courses/)

## **Задачи на базовые запросы**

### Задача 1
Выведите все записи из таблицы products, отсортировав их по наименованиям товаров в алфавитном порядке, т.е. по возрастанию.

```sql
SELECT *
  FROM products
 ORDER BY name;
```

### Задача 2
Отсортируйте таблицу **courier_actions** сначала по колонке **courier_id** по возрастанию id курьера, потом по колонке **action** (снова по возрастанию), а затем по колонке **time**, но уже по убыванию — от самого последнего действия к самому первому. Не забудьте включить в результат колонку **order_id**.
Добавьте в запрос оператор **LIMIT** и выведите только **первые 1000** строк результирующей таблицы.
Поля в результирующей таблице: **courier_id**, **order_id**, **action, time**.

```sql
SELECT courier_id, order_id, action, time
  FROM courier_actions
 ORDER BY courier_id, action, time DESC
 LIMIT 1000;
```

### Задача 3
Определите 5 самых дорогих товаров в таблице **products**, которые доставляет наш сервис. Выведите их наименования и цену.
Поля в результирующей таблице: **name**, **price**.

```sql
SELECT name, price
  FROM products
 ORDER BY price DESC
 LIMIT 5;
```

### Задача 4
Как в прошлом задании определите 5 самых дорогих товаров в таблице **products**. Но теперь колонки **name** и **price** переименуйте соответственно в **product_name** и **product_price**.
Поля в результирующей таблице: **product_name**, **product_price**.

```sql
SELECT name AS product_name,
       price AS product_price
  FROM products
 ORDER BY price DESC
 LIMIT 5;
```

### Задача 5
Определите товар с самым длинным названием в таблице **products**. Выведите его наименование, длину наименования в символах, а также цену этого товара. Колонку с длиной наименования в символах назовите **name_length**.
Поля в результирующей таблице: **name**, **name_length**, **price**.

```sql
SELECT name,
       length(name) AS name_length,
       price
  FROM products
 ORDER BY name_length DESC
 LIMIT 1;
```

### Задача 5
Примените последовательно функции **UPPER** и **SPLIT_PART** к колонке name и преобразуйте наименования товаров в таблице **products** так, чтобы от названий осталось только первое слово, записанное в верхнем регистре. Колонку с новым названием, состоящим из первого слова, назовите **first_word**.
В результат включите исходные наименования товаров, новые наименования из первого слова, а также цену товаров. Результат отсортируйте по возрастанию исходного наименования товара в колонке **name**.
Поля в результирующей таблице: **name**, **first_word**, **price**.

```sql
SELECT name,
       UPPER(SPLIT_PART(name, ' ', 1)) AS first_word,
       price
  FROM products
 ORDER BY name;
```
### Задача 6
Измените тип колонки **price** из таблицы **products** на **VARCHAR**. Выведите колонки с наименованием товаров, ценой в исходном формате и ценой в формате **VARCHAR**. Новую колонку с ценой в новом формате назовите **price_char**.
Результат отсортируйте по возрастанию наименования товара в колонке name. Количество выводимых записей не ограничивайте.
Поле в результирующей таблице: **name**, **price**, **price_char**.

```sql
SELECT name,
       price :: varchar AS price_char,
       price
  FROM products
 ORDER BY name;
```

### Задача 7
Для первых 200 записей из таблицы orders выведите информацию в следующем виде (обратите внимание на пробелы):
Заказ № [*id заказа*] создан [*дата*]
Полученную колонку назовите **order_info**.

```sql
SELECT CONCAT('Заказ № ', order_id, ' создан ', DATE(creation_time)) AS order_info
  FROM orders
 LIMIT 200;
```

### Задача 8
Выведите **id** всех курьеров и их годы рождения из таблицы **couriers**.
Год рождения необходимо получить из колонки **birth_date**. Новую колонку с годом назовите **birth_year**. 
Результат отсортируйте сначала по убыванию года рождения курьера (т.е. от самых младших к самым старшим), затем по возрастанию **id** курьера.
Поля в результирующей таблице: **courier_id**, **birth_year**.

```sql
SELECT courier_id,
       DATE_PART('year', birth_date) AS birth_year
  FROM couriers
 ORDER BY birth_year DESC, courier_id;
```

### Задача 9
Как и в предыдущем задании, снова выведите **id** всех курьеров и их годы рождения, только теперь к извлеченному году примените функцию **COALESCE**. Укажите параметры функции так, чтобы вместо **NULL** значений в результат попадало текстовое значение **unknown**. Названия полей оставьте прежними.
Отсортируйте итоговую таблицу сначала по убыванию года рождения курьера, затем по возрастанию id курьера.
Поля в результирующей таблице: **courier_id**, **birth_year**.

```sql
SELECT courier_id,
       COALESCE(DATE_PART('year', birth_date)::varchar, 'unknown') AS birth_year
  FROM couriers
 ORDER BY birth_year DESC, courier_id;
```

### Задача 10
Давайте представим, что по какой-то необъяснимой причине мы вдруг решили в одночасье повысить цену всех товаров в таблице **products** на **5%**.
Выведите **id** и наименования всех товаров, их старую и новую цену. Колонку со старой ценой назовите **old_price**, а колонку с новой — **new_price**.
Результат отсортируйте сначала по убыванию новой цены, затем по возрастанию **id** товара.
Поля в результирующей таблице: **product_id**, **name**, **old_price**, **new_price**.

```sql
SELECT product_id,
       name,
       price AS old_price,
       price * 1.05 AS new_price
  FROM products
 ORDER BY new_price DESC, product_id;
```

### Задача 10
Вновь, как и в прошлом задании, повысьте цену всех товаров на **5%**, только теперь к колонке с новой ценой примените функцию **ROUND**. Выведите **id** и наименования товаров, их старую цену, а также новую цену с округлением. Новую цену округлите до одного знака после запятой, но тип данных не меняйте.
Результат отсортируйте сначала по убыванию новой цены, затем по возрастанию **id** товара.
Поля в результирующей таблице: **product_id, name, old_price, new_price**.

```sql
SELECT product_id,
       name,
       price AS old_price,
       round(price*1.05, 1) AS new_price
  FROM products
 ORDER BY new_price DESC, product_id;
```

### Задача 11
Повысьте цену на **5%** только на те товары, цена которых **превышает 100 рублей**. Цену остальных товаров оставьте без изменений. Также не повышайте цену на икру, которая и так стоит **800 рублей**. Выведите **id** и наименования всех товаров, их старую и новую цену. Цену округлять не нужно.
Результат отсортируйте сначала по убыванию новой цены, затем по возрастанию id товара.
Поля в результирующей таблице: **product_id, name, old_price, new_price**.

```sql
SELECT product_id,
       name,
       price AS old_price,
       CASE WHEN name = 'икра' THEN price
            WHEN price > 100 THEN price * 1.05
            ELSE price
            END AS new_price
  FROM products
 ORDER BY new_price DESC, product_id;
```

### Задача 12
Вычислите НДС каждого товара в таблице **products** и рассчитайте цену без учёта НДС. Выведите всю информацию о товарах, включая сумму налога и цену без его учёта. Колонки с суммой налога и ценой без НДС назовите соответственно **tax** и **price_before_tax**. Округлите значения в этих колонках до двух знаков после запятой.
Результат отсортируйте сначала **по убыванию цены товара без учёта НДС, затем по возрастанию id товара**.
Поля в результирующей таблице: **product_id, name, price, tax, price_before_tax**.

```sql
SELECT product_id,
       name,
       price,
       ROUND(price / 120 * 20, 2) AS tax,
       ROUND(price - price / 120 * 20, 2) AS price_before_tax
  FROM products
 ORDER BY price_before_tax DESC, product_id;
```

## **Задачи ни фильтрацию данных**

### Задача 13
Напишите SQL-запрос к таблице **products** и выведите всю информацию о товарах, цена которых не превышает 100 рублей. Результат отсортируйте по возрастанию **id** товара.
Поля в результирующей таблице: **product_id, name, price**.

```sql
SELECT product_id,
       name,
       price
  FROM products
 WHERE price <= 100
 ORDER BY product_id
 LIMIT 100;
```

### Задача 14
Отберите пользователей женского пола **(female)** из таблицы **users**. Выведите только **id** этих пользователей. Результат отсортируйте по возрастанию **id**.
Добавьте в запрос оператор **LIMIT** и выведите **только 1000 первых id** из отсортированного списка.
Поле в результирующей таблице: **user_id**.

```sql
SELECT user_id
  FROM users
 WHERE sex = 'female'
 ORDER BY user_id
 LIMIT 1000;
```

### Задача 15
Отберите из таблицы **user_actions** все действия пользователей по созданию заказов, которые были совершены ими после полуночи **6 сентября 2022 года**. Выведите колонки с **id** пользователей, **id** созданных заказов и временем их создания.
Результат должен быть отсортирован **по возрастанию id** заказа.
Поля в результирующей таблице: **user_id, order_id, time**.
Обратите внимание, что в таблице **user_actions** у каждого пользователя могут быть записи не только со временем создания заказа, но и временем его отмены. Нам необходимо получить только записи с созданием заказов.

```sql
SELECT user_id,
       order_id,
       time
  FROM user_actions
 WHERE time >= '2022-09-06'
   AND action = 'create_order'
 ORDER BY order_id;
```

### Задача 16
Назначьте **скидку 20%** на все товары из таблицы **products** и отберите те, цена на которые с учётом скидки **превышает 100 рублей**. Выведите **id** товаров, их наименования, прежнюю цену и новую цену с учётом скидки. Колонку со старой ценой назовите **old_price**, с новой — **new_price**.
Результат должен быть отсортирован по возрастанию **id** товара.
Поля в результирующей таблице: **product_id, name, old_price, new_price**.

```sql
SELECT product_id,
       name,
       price AS old_price,
       price * 0.8 AS new_price
  FROM products
 WHERE price * 0.8 > 100
 ORDER BY product_id ASC;
```

### Задача 17
Отберите из таблицы **products** все товары, названия которых либо начинаются со слова **«чай»**, либо состоят из пяти символов. Выведите две колонки: **id товаров** и их наименования.
Результат должен быть отсортирован **по возрастанию id товара**.
Поля в результирующей таблице: **product_id, name**.

```sql
SELECT product_id,
       name
  FROM products
 WHERE split_part(name, ' ', 1) = 'чай'
    OR length(name) = 5
 ORDER BY product_id ASC;
```

### Задача 18
Отберите из таблицы **products** все товары, содержащие в своём названии последовательность символов «чай» (без кавычек). Выведите две колонки: **id** продукта и его название.
Результат должен быть отсортирован по возрастанию **id** товара.
Поля в результирующей таблице: **product_id, name**.

```sql
SELECT product_id,
       name
  FROM products
 WHERE name LIKE '%чай%'
 ORDER BY product_id ASC;
```

### Задача 19
Выберите из таблицы **products id** и наименования только тех товаров, названия которых начинаются на букву «с» и содержат только одно слово.
Результат должен быть отсортирован по возрастанию **id** товара.
Поля в результирующей таблице: **product_id, name**.

```sql
SELECT product_id,
       name
  FROM products
 WHERE name LIKE 'с%'
   AND name NOT LIKE '% %'
 ORDER BY product_id ASC;
```

### Задача 20
Составьте SQL-запрос, который выбирает из таблицы **products** все чаи стоимостью больше 60 рублей и вычисляет для них цену **со скидкой 25%**.
Скидку в % менеджер попросил указать в отдельном столбце в формате текста, то есть вот так: «25%» (без кавычек). Столбцы со скидкой и новой ценой назовите соответственно **discount** и **new_price**.
Также необходимо любым известным способом избавиться от «чайного гриба»: вряд ли менеджер имел в виду и его, когда ставил нам задачу.
Результат должен быть отсортирован **по возрастанию id** товара.
Поля в результирующей таблице: **product_id, name, price, discount, new_price**.

```sql
SELECT product_id,
       name,
       price,
       '25%' AS discount,
       price * 0.75 AS new_price
  FROM products
 WHERE name LIKE '%чай%'
   AND price > 60
   AND name NOT LIKE 'чайный гриб'
 ORDER BY product_id ASC;
```

### Задача 21
Из таблицы user_actions выведите всю информацию о действиях пользователей с **id 170, 200 и 230 за период с 25 августа по 4 сентября 2022 года включительно**. Результат отсортируйте по **убыванию id** заказа — то есть от самых поздних действий к самым первым.
Поля в результирующей таблице: **user_id, order_id, action, time**.

```sql
SELECT user_id,
       order_id,
       action,
       time
  FROM user_actions
 WHERE user_id IN(170, 200, 230)
   AND time BETWEEN '2022-08-25'
   AND '2022-09-05'
 ORDER BY order_id DESC;
```

### Задача 22
Напишите SQL-запрос к таблице **couriers** и выведите всю информацию о курьерах, у которых не указан их день рождения.
Результат должен быть отсортирован **по возрастанию id курьера**.
Поля в результирующей таблице: **birth_date, courier_id, sex**.

```sql
SELECT birth_date,
       courier_id,
       sex
  FROM couriers
 WHERE birth_date IS NULL
 ORDER BY courier_id ASC;
```

### Задача 23
Определите id и даты рождения 50 самых молодых пользователей мужского пола из таблицы **users**. Не учитывайте тех пользователей, у которых не указана дата рождения.
Поле в результирующей таблице: **user_id, birth_date**.

```sql
SELECT user_id,
       birth_date
  FROM users
 WHERE sex = 'male'
   AND birth_date IS NOT NULL
 ORDER BY birth_date DESC
 LIMIT 50;
```

### Задача 24
Напишите SQL-запрос к таблице **courier_actions**, чтобы узнать **id** и время доставки **последних 10 заказов**, доставленных курьером с **id 100**.
Поля в результирующей таблице: **order_id, time**.

```sql
SELECT order_id,
       time
  FROM courier_actions
 WHERE courier_id = 100
   AND action = 'deliver_order'
 ORDER BY order_id DESC
 LIMIT 10;
```

### Задача 25
Из таблицы **user_actions** получите **id** всех заказов, сделанных пользователями сервиса **в августе 2022 года**.
Результат отсортируйте **по возрастанию id заказа**.
Поле в результирующей таблице: **order_id**.

```sql
SELECT order_id
  FROM user_actions
 WHERE action = 'create_order'
   AMD DATE_PART('year', time) = 2022
   AND DATE_PART('month', time) = 08
 ORDER BY order_id ASC;
```

### Задача 26
Из таблицы **couriers** отберите **id** всех курьеров, родившихся в период **с 1990 по 1995 год** включительно.
Результат отсортируйте **по возрастанию id курьера**.
Поле в результирующей таблице: **courier_id**.

```sql
SELECT courier_id
  FROM couriers
 WHERE DATE_PART('year', birth_date) BETWEEN 1990
   AND 1995
ORDER BY courier_id ASC;
```

### Задача 27
Из таблицы **user_actions** получите информацию о всех отменах заказов, которые пользователи совершали в течение **августа 2022 года по средам с 12:00 до 15:59:59**.
Результат отсортируйте **по убыванию id отменённых заказов**.
Поля в результирующей таблице: **user_id, order_id, action, time**.

```sql
SELECT user_id,
       order_id,
       action,
       time
  FROM user_actions
 WHERE action = 'cancel_order'
   AND DATE_PART('year', time) = 2022
   AND DATE_PART('month', time) = 8
   AND DATE_PART('dow', time) = 3
   AND DATE_PART('hour', time) BETWEEN 12
   AND 15
ORDER BY order_id DESC;
```

### Задача 28
Вычислите НДС каждого товара в таблице products и рассчитайте цену без учёта НДС. Однако теперь примите во внимание, что для товаров из списка налог составляет **10%**. Для остальных товаров НДС тот же — **20%**.
Выведите всю информацию о товарах, включая сумму налога и цену без его учёта. Колонки с суммой налога и ценой без НДС назовите соответственно **tax** и **price_before_tax**. Округлите значения в этих колонках до двух знаков после запятой.
Результат отсортируйте сначала **по убыванию цены товара без учёта НДС**, затем **по возрастанию id товара**.
Поля в результирующей таблице: **product_id, name, price, tax, price_before_tax**.

```sql
SELECT product_id,
       name,
       price,
  CASE WHEN name IN('сахар', 'сухарики', 'сушки', 'семечки', 'масло льняное', 'виноград', 'масло оливковое', 'арбуз', 'батон', 'йогурт', 'сливки', 'гречка', 'овсянка', 'макароны', 'баранина', 'апельсины', 'бублики', 'хлеб', 'горох', 'сметана', 'рыба копченая', 'мука', 'шпроты', 'сосиски', 'свинина', 'рис', 'масло кунжутное', 'сгущенка', 'ананас', 'говядина', 'соль', 'рыба вяленая', 'масло подсолнечное', 'яблоки', 'груши', 'лепешка', 'молоко', 'курица', 'лаваш', 'вафли', 'мандарины') THEN ROUND(price / 110 * 10, 2)
  ELSE ROUND(price / 120 * 20, 2)
   END AS tax,
  CASE WHEN name IN('сахар', 'сухарики', 'сушки', 'семечки', 'масло льняное', 'виноград', 'масло оливковое', 'арбуз', 'батон', 'йогурт', 'сливки', 'гречка', 'овсянка', 'макароны', 'баранина', 'апельсины', 'бублики', 'хлеб', 'горох', 'сметана', 'рыба копченая', 'мука', 'шпроты', 'сосиски', 'свинина', 'рис', 'масло кунжутное', 'сгущенка', 'ананас', 'говядина', 'соль', 'рыба вяленая', 'масло подсолнечное', 'яблоки', 'груши', 'лепешка', 'молоко', 'курица', 'лаваш', 'вафли', 'мандарины') THEN ROUND(price - price / 110 * 10, 2)
  ELSE ROUND(price - price / 120 * 20, 2)
   END AS price_before_tax
  FROM   products
 ORDER BY price_before_tax DESC, product_id;
```

## **Агрегация данных**

### Задача 29
Выведите id всех уникальных пользователей из таблицы **user_actions**. Результат отсортируйте **по возрастанию id**.
Поле в результирующей таблице: **user_id**.

```sql
SELECT DISTINCT user_id
  FROM user_actions
 ORDER BY user_id ASC;
```

### Задача 30
Примените DISTINCT сразу к двум колонкам таблицы **courier_actions** и отберите уникальные пары значений **courier_id** и **order_id**.
Результат отсортируйте сначала по возрастанию **id курьера**, затем по возрастанию **id заказа**.
Поля в результирующей таблице: **courier_id, order_id**.

```sql
SELECT DISTINCT courier_id,
                order_id
  FROM  courier_actions
 ORDER BY courier_id, order_id;
```

### Задача 31
Посчитайте максимальную и минимальную цены товаров в таблице **products**. Поля назовите соответственно **max_price, min_price**.
Поля в результирующей таблице: **max_price, min_price**.

```sql
SELECT MAX(price) AS max_price,
       MIN(price) AS min_price
  FROM products;
```

### Задача 32
В таблице **users** у некоторых пользователей не были указаны их даты рождения.
Посчитайте в одном запросе количество всех записей в таблице и количество только тех записей, для которых в колонке **birth_date** указана дата рождения.
Колонку с общим числом записей назовите **dates**, а колонку с записями без пропусков — **dates_not_null**.
Поля в результирующей таблице: **dates, dates_not_null**.

```sql
SELECT COUNT(*) AS dates,
       COUNT(birth_date) AS dates_not_null
  FROM users;
```

### Задача 33
Посчитайте количество всех значений в колонке **user_id** в таблице **user_actions**, а также количество уникальных значений в этой колонке (т.е. количество уникальных пользователей сервиса).
Колонку с первым полученным значением назовите **users**, а колонку со вторым — **unique_users**.
Поля в результирующей таблице: **users, unique_users**.

```sql
SELECT COUNT(*) AS users,
       COUNT(distinct user_id) AS unique_users
  FROM user_actions;
```

### Задача 34
Посчитайте количество курьеров женского пола в таблице **couriers**. Полученный столбец с одним значением назовите **couriers**.
Поле в результирующей таблице: **couriers**.

```sql
SELECT COUNT(courier_id) AS couriers
  FROM couriers
 WHERE sex = 'female';
```

### Задача 35
Рассчитайте время, когда были совершены первая и последняя доставки заказов в таблице **courier_actions**.
Колонку с временем первой доставки назовите **first_delivery**, а колонку с временем последней — **last_delivery**.
Поля в результирующей таблице: **first_delivery, last_delivery**.

```sql
SELECT MIN(time) AS first_delivery,
       MAX(time) AS last_delivery
  FROM courier_actions
 WHERE action = 'deliver_order';
```

### Задача 36
Представьте, что один из пользователей сервиса сделал заказ, в который вошли одна пачка сухариков, одна пачка чипсов и один энергетический напиток. Посчитайте стоимость такого заказа.
Колонку с рассчитанной стоимостью заказа назовите **order_price**.
Для расчётов используйте таблицу **products**.
Поле в результирующей таблице: **order_price**.

```sql
SELECT SUM(price) AS order_price
  FROM products
 WHERE name IN('сухарики', 'чипсы', 'энергетический напиток');
```

### Задача 37
Посчитайте количество заказов в таблице **orders** с девятью и более товарами.
```sql
SELECT COUNT(*) AS orders
  FROM orders
 WHERE ARRAY_LENGTH(product_ids, 1) >= 9;
```

### Задача 38
С помощью функции AGE и агрегирующей функции рассчитайте возраст самого молодого курьера мужского пола в таблице **couriers**.
Возраст выразите количеством лет, месяцев и дней (как в примере выше), переведя его в тип VARCHAR. 
В качестве даты, относительно которой считать возраст курьеров, используйте свою текущую дату (либо не указывайте её на месте первого аргумента, как показано в примерах).
Полученную колонку со значением возраста назовите **min_age**.
Поле в результирующей таблице: min_age

```sql
SELECT AGE(current_date, max(birth_date))::varchar as min_age
  FROM couriers
 WHERE sex = 'male';
```

### Задача 39
Посчитайте стоимость заказа, в котором будут **три пачки сухариков, две пачки чипсов и один энергетический напиток**. Колонку с рассчитанной стоимостью заказа назовите **order_price**.
Для расчётов используйте таблицу **products**.
Поле в результирующей таблице: **order_price**.

```sql
SELECT SUM(CASE WHEN name = 'сухарики' THEN price * 3
                WHEN name = 'чипсы' THEN price * 2
                WHEN name = 'энергетический напиток' THEN price
                ELSE 0
                END) AS order_price
  FROM products;
```

### Задача 40
Рассчитайте среднюю цену товаров в таблице **products**, в названиях которых присутствуют слова «чай» или «кофе». Любым известным способом исключите из расчёта товары, содержащие в названии «иван-чай» или «чайный гриб».
Среднюю цену округлите до двух знаков после запятой. Столбец с полученным значением назовите **avg_price**.
Поле в результирующей таблице: **avg_price**.

```sql
SELECT ROUND(AVG(price), 2) AS avg_price
  FROM products
 WHERE (name LIKE '%чай%'
    OR name LIKE '%кофе%')
   AND name NOT LIKE '%иван-чай%'
   AND name NOT LIKE '%чайный гриб%';
```

### Задача 41
Воспользуйтесь функцией AGE и рассчитайте разницу в возрасте между самым старым и самым молодым пользователями женкского пола в таблице **users**. 
Разницу в возрасте выразите количеством лет, месяцев и дней, переведя её в тип VARCHAR. 
Колонку с посчитанным значением назовите **age_diff**.
Поле в результирующей таблице: **age_diff**.

```sql
SELECT AGE(MAX(birth_date), MIN(birth_date))::varchar AS age_diff
  FROM users
 WHERE sex = 'male';
```
### Задача 42
Рассчитайте среднее количество товаров в заказах из таблицы **orders**, которые пользователи оформляли по выходным дням (суббота и воскресенье) в течение всего времени работы сервиса.
Полученное значение округлите до двух знаков после запятой. Колонку с ним назовите **avg_order_size**.
Поле в результирующей таблице: **avg_order_size**.

```sql
SELECT ROUND(AVG(ARRAY_LENGTH(product_ids, 1)), 2) AS avg_order_size
  FROM orders
 WHERE DATE_PART('dow', creation_time) IN (6, 0);
```

### Задача 43
На основе данных в таблице **user_actions** посчитайте количество уникальных пользователей сервиса, количество уникальных заказов, поделите одно на другое и выясните, сколько заказов приходится на одного пользователя.
В результирующей таблице отразите все три значения — поля назовите соответственно **unique_users, unique_orders, orders_per_user**.
Показатель числа заказов на пользователя округлите до двух знаков после запятой.
Поля в результирующей таблице: **unique_users, unique_orders, orders_per_user**.

```sql
SELECT COUNT(DISTINCT user_id) AS unique_users,
       COUNT(DISTINCT order_id) AS unique_orders,
       ROUND(COUNT(DISTINCT order_id)::decimal / COUNT(DISTINCT user_id), 2) AS orders_per_user
  FROM user_actions;
```
### Задача 43
Посчитайте, сколько пользователей никогда не отменяли свой заказ.
Полученный столбец назовите **users_count**.
Поле в результирующей таблице: **users_count**.

```sql
SELECT COUNT(DISTINCT user_id) - COUNT(DISTINCT user_id) filter (WHERE action = 'cancel_order') AS users_count
  FROM user_actions;
```

### Задача 44
Посчитайте общее количество заказов в таблице orders, количество заказов с пятью и более товарами и найдите долю заказов с пятью и более товарами в общем количестве заказов.
В результирующей таблице отразите все три значения — поля назовите соответственно **orders, large_orders, large_orders_share**.
Долю заказов с пятью и более товарами в общем количестве товаров округлите до двух знаков после запятой.
Поля в результирующей таблице: **orders, large_orders, large_orders_share**.

```sql
SELECT COUNT(order_id) AS orders,
       COUNT(order_id) filter (WHERE ARRAY_LENGTH(product_ids, 1) >= 5) AS large_orders,
       ROUND(COUNT(order_id) filter (WHERE ARRAY_LENGTH(product_ids, 1) >= 5)::decimal / count(order_id), 2) AS large_orders_share
  FROM orders;
```

### Задача 45
С помощью оператора **GROUP BY** посчитайте количество курьеров мужского и женского пола в таблице couriers.
Новую колонку с числом курьеров назовите **couriers_count**.
Результат отсортируйте по этой колонке по возрастанию.
Поля в результирующей таблице: **sex, couriers_count**.

```sql
SELECT sex,
       COUNT(courier_id) AS couriers_count
  FROM couriers
 GROUP BY sex
 ORDER BY sex;
```

### Задача 46
Посчитайте количество созданных и отменённых заказов в таблице **user_actions**.
Новую колонку с числом заказов назовите **orders_count**.
Результат отсортируйте по числу заказов по возрастанию.
Поля в результирующей таблице: **action, orders_count**.

```sql
SELECT action,
       COUNT(action) AS orders_count
 FROM  user_actions
 GROUP BY action
 ORDER BY orders_count;
```

### Задача 47
Используя группировку и функцию **DATE_TRUNC**, приведите все даты к началу месяца и посчитайте, сколько заказов было сделано в каждом из них.
Расчёты проведите по таблице **orders**. Колонку с усечённой датой назовите **month**, колонку с количеством заказов — **orders_count**.
Результат отсортируйте по месяцам — по возрастанию.
Поля в результирующей таблице: **month, orders_count**.

```sql
SELECT DATE_TRUNC('month', creation_time) AS month,
       COUNT(product_ids) AS orders_count
  FROM orders
 GROUP BY month
 ORDER BY month;
```

### Задача 48
Используя группировку и функцию **DATE_TRUNC**, приведите все даты к началу месяца и посчитайте, сколько заказов было сделано и сколько было отменено в каждом из них.
В этот раз расчёты проведите по таблице **user_actions**. Колонку с усечённой датой назовите **month**, колонку с количеством заказов — **orders_count**.
Результат отсортируйте сначала по месяцам — по возрастанию, затем по типу действия — тоже по возрастанию.
Поля в результирующей таблице: **month, action, orders_count**.

```sql
SELECT DATE_TRUNC('month', time) AS month,
       action,
       COUNT(order_id) AS orders_count
  FROM user_actions
 GROUP BY month, action
 ORDER BY month, action;
```

### Задача 49
По данным в таблице **users** посчитайте максимальный порядковый номер месяца среди всех порядковых номеров месяцев рождения пользователей сервиса. С помощью группировки проведите расчёты отдельно в двух группах — для пользователей мужского и женского пола.
Новую колонку с максимальным порядковым номером месяца рождения в группах назовите **max_month**. Преобразуйте значения в новой колонке в формат **INTEGER**, чтобы порядковый номер был выражен целым числом.
Результат отсортируйте по колонке с полом пользователей.
Поля в результирующей таблице: **sex, max_month**.

```sql
SELECT sex,
       MAX(DATE_PART('month', birth_date)::integer) AS max_month
  FROM users
 GROUP BY sex
 ORDER BY sex;
```

### Задача 50
По данным в таблице **users** посчитайте порядковый номер месяца рождения самого молодого пользователя сервиса. С помощью группировки проведите расчёты отдельно в двух группах — для пользователей мужского и женского пола.
Новую колонку c порядковым номером месяца рождения самого молодого пользователя в группах назовите **max_month**. Преобразуйте значения в новой колонке в формат **INTEGER**, чтобы порядковый номер был выражен целым числом.
Результат отсортируйте по колонке с полом пользователей.
Поля в результирующей таблице: **sex, max_month**.

```sql
SELECT sex,
       DATE_PART('month', MAX(birth_date))::integer AS max_month
  FROM users
 GROUP BY sex
 ORDER BY sex;
```

### Задача 51
Посчитайте максимальный возраст пользователей мужского и женского пола в таблице users. Возраст измерьте числом полных лет.
Новую колонку с возрастом назовите **max_age**. Преобразуйте значения в новой колонке в формат **INTEGER**, чтобы возраст был выражен целым числом.
Результат отсортируйте по новой колонке по возрастанию возраста.
Поля в результирующей таблице: **sex, max_age**.

```sql
SELECT sex,
        DATE_PART('year', MAX(AGE(birth_date)))::integer as max_age
  FROM users
 GROUP BY sex
 ORDER BY max_age;
```

### Задача 52
Разбейте пользователей из таблицы **users** на группы по возрасту (возраст по-прежнему измеряем числом полных лет) и посчитайте количество пользователей каждого возраста.
Колонку с возрастом назовите **age**, а колонку с числом пользователей — **users_count**. Преобразуйте значения в колонке с возрастом в формат **INTEGER**, чтобы возраст был выражен целым числом.
Результат отсортируйте по колонке с возрастом по возрастанию.
Поля в результирующей таблице: **age, users_count**.

```sql
SELECT DATE_PART('year', AGE(birth_date))::integer AS age,
       COUNT(user_id) AS users_count
  FROM users
 GROUP BY age
 ORDER BY age;
```

### Задача 53
Вновь разбейте пользователей из таблицы **users** на группы по возрасту (возраст по-прежнему измеряем количеством полных лет), только теперь добавьте в группировку ещё и пол пользователя. Затем посчитайте количество пользователей в каждой половозрастной группе.
Все **NULL** значения в колонке **birth_date** заранее отфильтруйте с помощью **WHERE**.
Колонку с возрастом назовите **age**, а колонку с числом пользователей — **users_count**, имя колонки с полом оставьте без изменений. Преобразуйте значения в колонке с возрастом в формат **INTEGER**, чтобы возраст был выражен целым числом.
Отсортируйте полученную таблицу сначала по колонке с возрастом по возрастанию, затем по колонке с полом — тоже по возрастанию.
Поля в результирующей таблице: **age, sex, users_count**.

```sql
SELECT DATE_PART('year', age(birth_date))::integer AS age,
       sex,
       COUNT(user_id) AS users_count
  FROM users
 WHERE birth_date IS NOT NULL
 GROUP BY age, sex
 ORDER BY age, sex;
```

### Задача 54
Посчитайте количество товаров в каждом заказе, примените к этим значениям группировку и рассчитайте количество заказов в каждой группе **за неделю с 29 августа по 4 сентября 2022 года включительно**. Для расчётов используйте данные из таблицы **orders**.
Выведите две колонки: размер заказа и число заказов такого размера за указанный период. Колонки назовите соответственно **order_size** и **orders_count**.
Результат отсортируйте по возрастанию размера заказа.
Поля в результирующей таблице: **order_size, orders_count**.

```sql
SELECT array_length(product_ids, 1) AS order_size,
       COUNT(order_id) AS orders_count
  FROM orders
 WHERE creation_time >= '2022-08-29'
   AND creation_time < '2022-09-05'
 GROUP BY array_length(product_ids, 1)
 ORDER BY order_size;
```

### Задача 55
Посчитайте количество товаров в каждом заказе, примените к этим значениям группировку и рассчитайте количество заказов в каждой группе. Учитывайте только заказы, оформленные по будням. В результат включите только те размеры заказов, общее число которых превышает 2000. Для расчётов используйте данные из таблицы **orders**.
Выведите две колонки: размер заказа и число заказов такого размера. Колонки назовите соответственно **order_size** и **orders_count**.
Результат отсортируйте по возрастанию размера заказа.
Поля в результирующей таблице: **order_size, orders_count**.

```sql
SELECT array_length(product_ids, 1) AS order_size,
       COUNT(order_id) AS orders_count
  FROM orders
 WHERE TO_CHAR(creation_time, 'Dy') NOT IN ('Sat', 'Sun')
 GROUP BY array_length(product_ids, 1)
HAVING COUNT(order_id) > 2000
 ORDER BY order_size;
```

### Задача 56
По данным из таблицы **user_actions** определите пять пользователей, сделавших **в августе 2022 года** наибольшее количество заказов.
Выведите две колонки — **id** пользователей и число оформленных ими заказов. Колонку с числом оформленных заказов назовите **created_orders**.
Результат отсортируйте сначала по убыванию числа заказов, сделанных пятью пользователями, затем по возрастанию **id** этих пользователей.
Поля в результирующей таблице: **user_id, created_orders**.

```sql
SELECT user_id,
       count(order_id) AS created_orders
  FROM user_actions
 WHERE action = 'create_order'
   and time >= '2022-08-01'
   and time < '2022-09-01'
GROUP BY user_id
ORDER BY created_orders DESC, user_id ASC limit 5;
```

### Задача 57
А теперь по данным таблицы courier_actions определите курьеров, которые **в сентябре 2022 года** доставили только по одному заказу.
В этот раз выведите всего одну колонку с **id курьеров**. Колонку с числом заказов в результат включать не нужно.
Результат отсортируйте по возрастанию id курьера.
Поле в результирующей таблице: **courier_id**.

```sql
SELECT courier_id
  FROM courier_actions
 WHERE time >= '2022-09-01'
   AND time < '2022-10-01'
 GROUP BY courier_id
HAVING COUNT(distinct order_id) = 1
 ORDER BY courier_id;
```

### Задача 58
Из таблицы **user_actions** отберите пользователей, у которых последний заказ был создан **до 8 сентября 2022 года**.
Выведите только их **id**, дату создания заказа выводить не нужно.
Результат отсортируйте по возрастанию id пользователя.
Поле в результирующей таблице: **user_id**.

```sql
SELECT user_id
  FROM user_actions
 WHERE action = 'create_order'
 GROUP BY user_id HAVING MAX(time) < '2022-09-08'
 ORDER BY user_id;
```
### Задача 58
Разбейте заказы из таблицы **orders** на **3 группы** в зависимости от **количества товаров**, попавших в заказ:
Малый (от 1 до 3 товаров);
Средний (от 4 до 6 товаров);
Большой (7 и более товаров).
Посчитайте число заказов, попавших в каждую группу. Группы назовите соответственно **«Малый», «Средний», «Большой» (без кавычек)**.
Выведите наименования групп и число товаров в них. Колонку с наименованием групп назовите **order_size**, а колонку с числом заказов — **orders_count**.
Отсортируйте полученную таблицу по колонке с числом заказов по возрастанию.
Поля в результирующей таблице: **order_size, orders_count**.

```sql
SELECT CASE WHEN array_length(product_ids, 1) >= 1 AND
                 array_length(product_ids, 1) <= 3 THEN 'Малый'
            WHEN array_length(product_ids, 1) >= 4 AND
                 array_length(product_ids, 1) <= 6 THEN 'Средний'
            ELSE 'Большой' END AS order_size,
       COUNT(DISTINCT order_id) AS orders_count
 FROM orders
GROUP BY order_size
ORDER BY orders_count;
```

### Задача 59
Разбейте пользователей из таблицы users на 4 возрастные группы:
от 18 до 24 лет;
от 25 до 29 лет;
от 30 до 35 лет;
не младше 36.

Посчитайте число пользователей, попавших в каждую возрастную группу. Группы назовите соответственно **«18-24», «25-29», «30-35», «36+» (без кавычек)**.
В расчётах не учитывайте пользователей, у которых не указана дата рождения. Как и в прошлых задачах, в качестве возраста учитывайте **число полных лет**.
Выведите наименования групп и число пользователей в них. Колонку с наименованием групп назовите **group_age**, а колонку с числом пользователей — **users_count**.
Отсортируйте полученную таблицу по колонке с наименованием групп по возрастанию.
Поля в результирующей таблице: **group_age, users_count**.

```sql
SELECT CASE WHEN date_part('year', age(birth_date)) BETWEEN 18 AND 24 THEN '18-24'
            WHEN date_part('year', age(birth_date)) BETWEEN 25 AND 29 THEN '25-29'
            WHEN date_part('year', age(birth_date)) BETWEEN 30 AND 35 THEN '30-35'
            WHEN date_part('year', age(birth_date)) >= 36 THEN '36+'
            END AS group_age,
       COUNT(user_id) AS users_count
  FROM users
 WHERE birth_date IS NOT NULL
 GROUP BY group_age
 ORDER BY group_age
```
### Задача 60
По данным из таблицы orders рассчитайте **средний размер заказа по выходным и будням**.
Группу с выходными днями (суббота и воскресенье) назовите **«weekend»**, а группу с будними днями (с понедельника по пятницу) — **«weekdays»** (без кавычек).
В результат включите две колонки: колонку с группами назовите **week_part**, а колонку со средним размером заказа — **avg_order_size**. 
Средний размер заказа округлите **до двух знаков после запятой**.
Результат отсортируйте по колонке со средним размером заказа — по возрастанию.
Поля в результирующей таблице: **week_part, avg_order_size**.

```sql
SELECT CASE WHEN date_part('dow', creation_time) IN (1, 2, 3, 4, 5) THEN 'weekdays'
            ELSE 'weekend'
            END AS week_part,
      ROUND(AVG(array_length(product_ids, 1)), 2) AS avg_order_size
  FROM orders
 GROUP BY week_part
 ORDER BY avg_order_size;
```





                                              
